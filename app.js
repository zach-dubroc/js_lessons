//types
// var ello = "hello";
// var num = 5;
// var bool = true;
// var undef = undefined;
// var none = null;

//temp convert
// var cels = 100;
// var far = (cels * 9/5) + 32;
// console.log(far)

//const, let, var

//consts are immuttable, block-scoped, hoisted like vars but can't be used before declaration
//const c = "immutable";

//lets are block scoped (closed in{}), can't be used before declared
// let number = "muteable, can be changed"
// number = "55"
// console.log("let: " + number)

//vars are function scoped, hoisted to top of their scope which means they can be used before declaration as undefined
// s=15
// var s;
// console.log("var: " + s)


/*
dynamically typed, variable types are determined at runtime.
Examples: Python, JavaScript, Ruby.
Pros: Easier to write and more flexible code.
Cons: Potential for runtime errors, slower performance.

statically typed, variable types are known and checked at compile time.
Examples: C#, Java, C++, Swift.
Pros: Early error detection, better performance.
Cons: Requires explicit type declarations, less flexible.
*/






let name = prompt("enter name: ");



















//----------------------------------------------------------------------

//ex. solutions

// Step 1: Prompt the user to enter their first name
// Step 2: Prompt the user to enter their last name
// Step 3: Display a greeting message using the first name and last name
// var firstName = prompt("enter first name: ")
// var lastName = prompt("enter last name: ")
// console.log(`hello there ${firstName} ${lastName}`)



//var a = 3;
//var b = 8;
//swap with temp var
// var temp = a;
// a = b;
// b = temp;
// console.log(`a = ${a}`)
// console.log(`b = ${b}`)
